import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet
reactions: amaltheaToAscet
in reaction to changes in amalthea
execute actions in ascet
reaction TaskCreated {
	after element amalthea::Task inserted into amalthea::ComponentContainer.tasks
	call createAscetTask(newValue)
}
routine createAscetTask(amalthea::Task createdTask) {
	match {
		val container = createdTask.eContainer as amalthea::ComponentContainer
		check container !== null
	}
	update {
		val options = newArrayList("InterruptTask", "PeriodicTask", "SoftwareTask", "TimeTableTask", "Nothing")
		val selection = userInteractor.selectOne("Create ASCET task for " + createdTask.name, options)
		switch selection {
			case "InterruptTask": createInterruptTask(createdTask)
			case "PeriodicTask": createPeriodicTask(createdTask)
			case "SoftwareTask": createSoftwareTask(createdTask)
			case "TimeTableTask": createTimeTableTask(createdTask)
			default: {}
		}
	}
}
routine createInterruptTask(amalthea::Task createdTask) {
	match {
		val container = createdTask.eContainer as amalthea::ComponentContainer
		val module = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to createdTask
		check module !== null
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::InterruptTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createPeriodicTask(amalthea::Task createdTask) {
	match {
		val container = createdTask.eContainer as amalthea::ComponentContainer
		val module = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to createdTask
		check module !== null
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::PeriodicTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createSoftwareTask(amalthea::Task createdTask) {
	match {
		val container = createdTask.eContainer as amalthea::ComponentContainer
		val module = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to createdTask
		check module !== null
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::SoftwareTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createTimeTableTask(amalthea::Task createdTask) {
	match {
		val container = createdTask.eContainer as amalthea::ComponentContainer
		val module = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to createdTask
		check module !== null
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::TimeTableTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
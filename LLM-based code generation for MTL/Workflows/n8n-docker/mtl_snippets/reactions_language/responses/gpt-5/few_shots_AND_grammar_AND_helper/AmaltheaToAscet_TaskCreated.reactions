import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet
reactions: amaltheaToAscet in reaction to changes in amalthea execute actions in ascet
reaction TaskCreated {
	after element amalthea::Task inserted in amalthea::ComponentContainer[tasks]
	call createAscetTask(newValue)
}
routine createAscetTask(amalthea::Task createdTask) {
	update {
		val selection = userInteractor.singleSelectionDialogBuilder.message("Select task type to create in ASCET").choices(#["InterruptTask","PeriodicTask","SoftwareTask","TimeTableTask","Nothing"]).startInteraction()
		switch selection {
			case 0: createInterruptTask(createdTask)
			case 1: createPeriodicTask(createdTask)
			case 2: createSoftwareTask(createdTask)
			case 3: createTimeTableTask(createdTask)
			default: {return}
		}
	}
}
routine createInterruptTask(amalthea::Task createdTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to createdTask.eContainer
		require absence of ascet::Task corresponding to createdTask
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::InterruptTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createPeriodicTask(amalthea::Task createdTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to createdTask.eContainer
		require absence of ascet::Task corresponding to createdTask
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::PeriodicTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createSoftwareTask(amalthea::Task createdTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to createdTask.eContainer
		require absence of ascet::Task corresponding to createdTask
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::SoftwareTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
routine createTimeTableTask(amalthea::Task createdTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to createdTask.eContainer
		require absence of ascet::Task corresponding to createdTask
		check module.tasks.forall[t | t.name != createdTask.name]
	}
	create {
		val newTask = new ascet::TimeTableTask
	}
	update {
		newTask.name = createdTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, createdTask)
	}
}
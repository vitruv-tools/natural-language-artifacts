import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet
reactions: amaltheaToAscet in reaction to changes in amalthea execute actions in ascet
reaction TaskCreated {
	after element amalthea::Task inserted in amalthea::ComponentContainer[tasks]
	call createAscetTask(newValue)
}
routine createAscetTask(amalthea::Task createdTask) {
	update {
		val options = #["InterruptTask","PeriodicTask","SoftwareTask","TimeTableTask","Nothing"]
		val selected = javax.swing.JOptionPane::showInputDialog(null, "Select the ASCET task type to create for '" + createdTask.name + "'", "Create ASCET Task", javax.swing.JOptionPane::QUESTION_MESSAGE, null, options.toArray, options.get(0))
		val choice = selected === null ? "Nothing" : selected.toString
		switch choice {
			case "InterruptTask": createInterruptTask(createdTask)
			case "PeriodicTask": createPeriodicTask(createdTask)
			case "SoftwareTask": createSoftwareTask(createdTask)
			case "TimeTableTask": createTimeTableTask(createdTask)
			default: null
		}
	}
}
routine createInterruptTask(amalthea::Task sourceTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to sourceTask.eContainer
		require absence of ascet::Task corresponding to sourceTask
		check module.tasks.filter[t | t.name == sourceTask.name].empty
	}
	create {
		val newTask = new ascet::InterruptTask
	}
	update {
		newTask.name = sourceTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, sourceTask)
	}
}
routine createPeriodicTask(amalthea::Task sourceTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to sourceTask.eContainer
		require absence of ascet::Task corresponding to sourceTask
		check module.tasks.filter[t | t.name == sourceTask.name].empty
	}
	create {
		val newTask = new ascet::PeriodicTask
	}
	update {
		newTask.name = sourceTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, sourceTask)
	}
}
routine createSoftwareTask(amalthea::Task sourceTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to sourceTask.eContainer
		require absence of ascet::Task corresponding to sourceTask
		check module.tasks.filter[t | t.name == sourceTask.name].empty
	}
	create {
		val newTask = new ascet::SoftwareTask
	}
	update {
		newTask.name = sourceTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, sourceTask)
	}
}
routine createTimeTableTask(amalthea::Task sourceTask) {
	match {
		val module = retrieve ascet::AscetModule corresponding to sourceTask.eContainer
		require absence of ascet::Task corresponding to sourceTask
		check module.tasks.filter[t | t.name == sourceTask.name].empty
	}
	create {
		val newTask = new ascet::TimeTableTask
	}
	update {
		newTask.name = sourceTask.name
		module.tasks += newTask
		addCorrespondenceBetween(newTask, sourceTask)
	}
}
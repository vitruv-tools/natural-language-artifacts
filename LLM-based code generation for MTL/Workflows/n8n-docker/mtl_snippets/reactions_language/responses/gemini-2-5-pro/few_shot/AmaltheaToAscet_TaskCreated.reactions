import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet
import "java.util.Arrays"
import "org.eclipse.jface.window.Window"
import "org.eclipse.ui.dialogs.ElementListSelectionDialog"
import "org.eclipse.swt.widgets.Display"
import "org.eclipse.jface.viewers.LabelProvider"

transformation amaltheaToAscet
in reaction to changes in amalthea
execute actions in ascet

reaction TaskCreated {
	after element amalthea::Task inserted into amalthea::ComponentContainer::tasks
	call createAscetTask(newValue, affectedEObject)
}

routine createAscetTask(amalthea::Task amaltheaTask, amalthea::ComponentContainer container) {
	xtend {
		val options = Arrays.asList("InterruptTask", "PeriodicTask", "SoftwareTask", "TimeTableTask")
		val dialog = new ElementListSelectionDialog(Display.getCurrent().getActiveShell(), new LabelProvider())
		dialog.setElements(options.toArray())
		dialog.setTitle("Select ASCET Task Type")
		dialog.setMessage("Select the type of ASCET task to create for '" + amaltheaTask.name + "'")
		if (dialog.open() == Window.OK) {
			val result = dialog.getFirstResult() as String
			switch (result) {
				case "InterruptTask": call createInterruptTask(amaltheaTask, container)
				case "PeriodicTask": call createPeriodicTask(amaltheaTask, container)
				case "SoftwareTask": call createSoftwareTask(amaltheaTask, container)
				case "TimeTableTask": call createTimeTableTask(amaltheaTask, container)
			}
		}
	}
}

routine createInterruptTask(amalthea::Task amaltheaTask, amalthea::ComponentContainer container) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.filter(ascet::Task).forall[it.name != amaltheaTask.name]
	}
	create {
		val newAscetTask = new ascet::InterruptTask
	}
	update {
		newAscetTask.name = amaltheaTask.name
		ascetModule.tasks.add(newAscetTask)
		addCorrespondenceBetween(newAscetTask, amaltheaTask)
	}
}

routine createPeriodicTask(amalthea::Task amaltheaTask, amalthea::ComponentContainer container) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.filter(ascet::Task).forall[it.name != amaltheaTask.name]
	}
	create {
		val newAscetTask = new ascet::PeriodicTask
	}
	update {
		newAscetTask.name = amaltheaTask.name
		ascetModule.tasks.add(newAscetTask)
		addCorrespondenceBetween(newAscetTask, amaltheaTask)
	}
}

routine createSoftwareTask(amalthea::Task amaltheaTask, amalthea::ComponentContainer container) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.filter(ascet::Task).forall[it.name != amaltheaTask.name]
	}
	create {
		val newAscetTask = new ascet::SoftwareTask
	}
	update {
		newAscetTask.name = amaltheaTask.name
		ascetModule.tasks.add(newAscetTask)
		addCorrespondenceBetween(newAscetTask, amaltheaTask)
	}
}

routine createTimeTableTask(amalthea::Task amaltheaTask, amalthea::ComponentContainer container) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.filter(ascet::Task).forall[it.name != amaltheaTask.name]
	}
	create {
		val newAscetTask = new ascet::TimeTableTask
	}
	update {
		newAscetTask.name = amaltheaTask.name
		ascetModule.tasks.add(newAscetTask)
		addCorrespondenceBetween(newAscetTask, amaltheaTask)
	}
}
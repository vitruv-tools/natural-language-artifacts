import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet

reactions: amaltheaToAscet
in reaction to changes in amalthea
execute actions in ascet

reaction TaskCreated {
	after element amalthea::Task inserted in amalthea::ComponentContainer[tasks]
	call createAscetTask(newValue)
}

routine createAscetTask(amalthea::Task createdAmaltheaTask) {
	update {
		val choices = #["InterruptTask", "PeriodicTask", "SoftwareTask", "TimeTableTask"]
		val selected = ui.selectFromList("Select Task Type", "Choose the type of ASCET task to create:", choices)
		if (selected !== null) {
			switch (selected) {
				case "InterruptTask": call createInterruptTask(createdAmaltheaTask)
				case "PeriodicTask": call createPeriodicTask(createdAmaltheaTask)
				case "SoftwareTask": call createSoftwareTask(createdAmaltheaTask)
				case "TimeTableTask": call createTimeTableTask(createdAmaltheaTask)
			}
		}
	}
}

routine createInterruptTask(amalthea::Task amaltheaTask) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to amaltheaTask.eContainer
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.forall[it.name != amaltheaTask.name]
	}
	create {
		val newInterruptTask = new ascet::InterruptTask
	}
	update {
		newInterruptTask.name = amaltheaTask.name
		ascetModule.tasks.add(newInterruptTask)
		addCorrespondenceBetween(newInterruptTask, amaltheaTask)
		persist(ascetModule)
	}
}

routine createPeriodicTask(amalthea::Task amaltheaTask) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to amaltheaTask.eContainer
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.forall[it.name != amaltheaTask.name]
	}
	create {
		val newPeriodicTask = new ascet::PeriodicTask
	}
	update {
		newPeriodicTask.name = amaltheaTask.name
		ascetModule.tasks.add(newPeriodicTask)
		addCorrespondenceBetween(newPeriodicTask, amaltheaTask)
		persist(ascetModule)
	}
}

routine createSoftwareTask(amalthea::Task amaltheaTask) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to amaltheaTask.eContainer
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.forall[it.name != amaltheaTask.name]
	}
	create {
		val newSoftwareTask = new ascet::SoftwareTask
	}
	update {
		newSoftwareTask.name = amaltheaTask.name
		ascetModule.tasks.add(newSoftwareTask)
		addCorrespondenceBetween(newSoftwareTask, amaltheaTask)
		persist(ascetModule)
	}
}

routine createTimeTableTask(amalthea::Task amaltheaTask) {
	match {
		val ascetModule = retrieve ascet::AscetModule corresponding to amaltheaTask.eContainer
		require absence of ascet::Task corresponding to amaltheaTask
		check ascetModule.tasks.forall[it.name != amaltheaTask.name]
	}
	create {
		val newTimeTableTask = new ascet::TimeTableTask
	}
	update {
		newTimeTableTask.name = amaltheaTask.name
		ascetModule.tasks.add(newTimeTableTask)
		addCorrespondenceBetween(newTimeTableTask, amaltheaTask)
		persist(ascetModule)
	}
}
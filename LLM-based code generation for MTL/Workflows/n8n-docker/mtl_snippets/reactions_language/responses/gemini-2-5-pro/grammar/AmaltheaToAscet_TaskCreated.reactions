import tools.vitruv.framework.userinteraction.UserInteracting
import "http://vitruv.tools/methodologisttemplate/amalthea" as amalthea
import "http://vitruv.tools/methodologisttemplate/ascet" as ascet
reactions: amaltheaToAscet 
in reaction to changes in amalthea 
execute actions in ascet {
	reaction TaskCreated {
		after element amalthea::Task aTask inserted in amalthea::ComponentContainer[tasks]
		call createAscetTask(aTask)
	}
	routine createAscetTask(amalthea::Task aTask) {
		update xtend {
			val selection = UserInteracting.selectFromList(
				"Create ASCET Task",
				"Select the type of ASCET task to create for " + aTask.name + ":",
				#["InterruptTask", "PeriodicTask", "SoftwareTask", "TimeTableTask"]
			)
			switch (selection) {
				case "InterruptTask": call(createInterruptTask(aTask))
				case "PeriodicTask": call(createPeriodicTask(aTask))
				case "SoftwareTask": call(createSoftwareTask(aTask))
				case "TimeTableTask": call(createTimeTableTask(aTask))
			}
		}
	}
	routine createInterruptTask(amalthea::Task aTask) {
		match {
			val ascetModule = retrieve ascet::AscetModule with { true }
			require absence of ascet::Task corresponding to aTask
		}
		create {
			val ascetTask = new ascet::InterruptTask
		}
		update {
			ascetTask.name = aTask.name
			ascetModule.tasks.add(ascetTask)
			correspondence.add(aTask, ascetTask)
		}
	}
	routine createPeriodicTask(amalthea::Task aTask) {
		match {
			val ascetModule = retrieve ascet::AscetModule with { true }
			require absence of ascet::Task corresponding to aTask
		}
		create {
			val ascetTask = new ascet::PeriodicTask
		}
		update {
			ascetTask.name = aTask.name
			ascetModule.tasks.add(ascetTask)
			correspondence.add(aTask, ascetTask)
		}
	}
	routine createSoftwareTask(amalthea::Task aTask) {
		match {
			val ascetModule = retrieve ascet::AscetModule with { true }
			require absence of ascet::Task corresponding to aTask
		}
		create {
			val ascetTask = new ascet::SoftwareTask
		}
		update {
			ascetTask.name = aTask.name
			ascetModule.tasks.add(ascetTask)
			correspondence.add(aTask, ascetTask)
		}
	}
	routine createTimeTableTask(amalthea::Task aTask) {
		match {
			val ascetModule = retrieve ascet::AscetModule with { true }
			require absence of ascet::Task corresponding to aTask
		}
		create {
			val ascetTask = new ascet::TimeTableTask
		}
		update {
			ascetTask.name = aTask.name
			ascetModule.tasks.add(ascetTask)
			correspondence.add(aTask, ascetTask)
		}
	}
}